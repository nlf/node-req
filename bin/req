#!/usr/bin/env node
var request = require('request'),
    fs = require('fs'),
    mime = require('mime'),
    url = require('url'),
    stream = require('stream'),
    argv = require('optimist')
        .alias('h', 'headers')
        .alias('f', 'file')
        .alias('d', 'data')
        .alias('o', 'options')
        .alias('q', 'query')
        .alias('t', 'timeout')
        .alias('w', 'write')
        .boolean('v')
        .argv,
    method,
    uri,
    body,
    headers,
    options,
    querystring,
    usage = 'req: [method] uri';

if (argv.d && argv.f) {
    console.log('only specify file or data, not both'); 
    process.exit(1);
}

if (argv._.length === 2) {
    method = argv._[0].toUpperCase();
    uri = argv._[1];
} else if (argv._.length === 1) {
    method = (argv.f || argv.d) ? 'POST' : 'GET';
    uri = argv._[0];
} else {
    console.log(usage);
    process.exit(1);
}

if (!uri.match(/^https?|ftp/)) {
    uri = 'http://' + uri;
}

if (argv.d) {
    headers = {};
    try {
        body = JSON.parse(argv.d);
        headers['content-type'] = 'application/json';
    } catch (err) {
        body = argv.d;
        headers['content-type'] = 'application/octet-stream';
        console.log('WARNING: defaulting Content-Type header to application/octet-stream');
    }
} else if (argv.f) {
    headers = {};
    headers['content-type'] = mime.lookup(argv.f);
    body = fs.readFileSync(argv.f);
}

if (argv.q) {
    var a = [];
    if (!(argv.q instanceof Array)) {
       a.push(argv.q);
    } else {
       a = argv.q;
    } 
    if (!querystring) querystring = {};
    for (var i = 0; i < a.length; i++) {
        var type, data;
        a[i] = a[i].replace(/=/, ':');
        type = a[i].substring(0, a[i].indexOf(':'));
        data = a[i].substring(a[i].indexOf(':') + 1);
        querystring[type] = data;
    }
}

if (argv.o) {
    var a = [];
    if (!(argv.o instanceof Array)) {
       a.push(argv.o);
    } else {
       a = argv.o;
    } 
    if (!options) options = {};
    for (var i = 0; i < a.length; i++) {
        var type, data;
        a[i] = a[i].replace(/=/, ':');
        type = a[i].substring(0, a[i].indexOf(':'));
        data = a[i].substring(a[i].indexOf(':') + 1);
        options[type] = data;
    }
}

if (argv.h) {
    var a = [];
    if (!(argv.h instanceof Array)) {
       a.push(argv.h);
    } else {
       a = argv.h;
    } 
    if (!headers) headers = {};
    for (var i = 0; i < a.length; i++) {
        var type, data;
        a[i] = a[i].replace(/=/, ':');
        type = a[i].substring(0, a[i].indexOf(':'));
        data = a[i].substring(a[i].indexOf(':') + 1);
        headers[type] = data;
    }
}

if (options) {
    options.encoding = null;
} else {
    options = { encoding: null };
}

var args = {};
if (headers) args.headers = headers;
if (querystring) args.qs = querystring;
if (body) args.body = body;
if (argv.t) args.timeout = parseInt(argv.t, 10);
Object.keys(options).forEach(function (key) {
    args[key] = options[key];
});
args.method = method;
args.uri = uri;
if (argv.v) console.log('REQUEST:', args);

function output(filename) {
    var realout = filename ? fs.createWriteStream(filename) : process.stdout;
    var writestream = new stream.Stream();
    writestream.writable = true;
    writestream.write = function (data) {
        var jdata;
        try {
            jdata = JSON.parse(data);
        } catch (err) {
            jdata = null;
        }
        if (realout === process.stdout) {
            console.log(jdata);
        } else {
            data = jdata ? JSON.stringify(jdata, null, 2) : data;
            realout.write(data);
        }
    }
    writestream.end = function (data) {
        if (realout === process.stdout) realout.write('\n');
    }
    return writestream;
}

function defCallback(err, res, body) {
    if (err) {
        console.log(err);
        process.exit(1);
    } else {
        if (argv.v) console.log('RESPONSE:', res.headers);
        if (body) {
            output(argv.w).write(body);
        } else {
            if (!argv.v) output(argv.w).write(JSON.stringify(res.headers));
        }
    }
}

if (method === 'GET') {
    var oldmethod = args.method;
    var filename = argv.w ? argv.w : null;
    args.method = 'HEAD';
    request(args, function (err, res, body) {
        if (err) {
            console.log(err);
            process.exit(1);
        } else {
            if (argv.v) console.log('RESPONSE:', res.headers);
            var ctype = res.headers['content-type'];
            if (!ctype.match(/^text|application\/json/)) {
                if (!filename) {
                    if (res.headers['content-disposition']) {
                        filename = res.headers['content-disposition'].match(/filename="?(.*)?"?/)[1];
                    } else {
                        var pathname = url.parse(uri).pathname.split('/');
                        filename = pathname[pathname.length - 1];
                    }
                    if (!filename) {
                        console.log('WARNING: could not determine filename, saving as "unknown"');
                        filename = 'unknown';
                    }
                }
            }
            args.method = oldmethod;
            delete args.callback;

            request(args).pipe(output(filename));
        }
    });
} else if (argv.f && (method === 'POST' || method === 'PUT')) {
    var file = fs.createReadStream(argv.f);
    file.pipe(request(args, defCallback));
} else {
    request(args, defCallback);
}
